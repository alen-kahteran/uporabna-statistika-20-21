knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.width = 8, fig.height = 5, out.width = "0.8\\textwidth")
x <- c(1.91, 1.94, 1.68, 1.75, 1.81, 1.83, 1.91, 1.95, 1.77, 1.98,
1.81, 1.75, 1.89, 1.89, 1.83, 1.89, 1.99, 1.65, 1.82, 1.65,
1.73, 1.73, 1.88, 1.81, 1.84, 1.83, 1.84, 1.72, 1.91, 1.63)
### Izberemo parametre apriorne porazdelitve
mu.0 <- 1.78
kappa.0 <- 1
sigma2.0 <- 0.1^2
nu.0 <- 1
### Izracunamo parametre aposteriorne porazdelitve
n <- length(x)
kappa.n <- kappa.0 + n
mu.n <- kappa.0/kappa.n * mu.0 + n/kappa.n * mean(x)
nu.n <- nu.0 + n
sigma2.n <- ( nu.0*sigma2.0 + (n-1)*var(x) +
n*kappa.0/kappa.n * (mean(x)-mu.0)^2 ) / nu.n
### Narisemo porazdelitev
# Prvi nacin: s parametrom 1/sigma^2
mu <- seq(1.7, 1.9, 0.0001)
prec2 <- seq(50, 170, 1)
apost <- matrix(NA, nrow = length(mu), ncol = length(prec2))
for (i in 1:length(mu)) {
for (j in 1:length(prec2)) {
apost[i, j] = dnorm(mu[i], mean = mu.n, sd = sqrt(1/(kappa.n*prec2[j]))) *
dgamma(prec2[j], nu.n/2, nu.n*sigma2.n/2)
}
}
par(mfrow = c(1,2))
contour(mu, prec2, apost)
# Drugi nacin: s parametrom sigma^2
#install.packages("invgamma")
library(invgamma)
mu <- seq(1.7, 1.9, 0.0001)
sigma2 <- seq(1/170, 1/50, 0.001)
apost <- matrix(NA, nrow = length(mu), ncol = length(sigma2))
for (i in 1:length(mu)) {
for (j in 1:length(sigma2)) {
apost[i, j] = dnorm(mu[i], mean = mu.n, sd = sqrt(sigma2[j]/kappa.n)) *
dinvgamma(sigma2[j], shape=nu.n/2, rate=nu.n*sigma2.n/2)
}
}
contour(mu,sigma2,apost)
par(mfrow=c(1,1))
### Izberemo parametre apriorne porazdelitve
mu.0 <- 1.78
kappa.0 <- 1
sigma2.0 <- 0.1^2
nu.0 <- 1
### Izracunamo parametre aposteriorne porazdelitve
n <- length(x)
kappa.n <- kappa.0 + n
mu.n <- kappa.0/kappa.n * mu.0 + n/kappa.n * mean(x)
nu.n <- nu.0 + n
sigma2.n <- ( nu.0*sigma2.0 + (n-1)*var(x) +
n*kappa.0/kappa.n * (mean(x)-mu.0)^2 ) / nu.n
### Narisemo porazdelitev
# Prvi nacin: s parametrom 1/sigma^2
mu <- seq(1.7, 1.9, 0.0001)
prec2 <- seq(50, 170, 1)
apost <- matrix(NA, nrow = length(mu), ncol = length(prec2))
for (i in 1:length(mu)) {
for (j in 1:length(prec2)) {
apost[i, j] = dnorm(mu[i], mean = mu.n, sd = sqrt(1/(kappa.n*prec2[j]))) *
dgamma(prec2[j], nu.n/2, nu.n*sigma2.n/2)
}
}
par(mfrow = c(1,2))
contour(mu, prec2, apost)
# Drugi nacin: s parametrom sigma^2
#install.packages("invgamma")
library(invgamma)
mu <- seq(1.7, 1.9, 0.0001)
sigma2 <- seq(1/170, 1/50, 0.001)
apost <- matrix(NA, nrow = length(mu), ncol = length(sigma2))
for (i in 1:length(mu)) {
for (j in 1:length(sigma2)) {
apost[i, j] = dnorm(mu[i], mean = mu.n, sd = sqrt(sigma2[j]/kappa.n)) *
dinvgamma(sigma2[j], shape=nu.n/2, rate=nu.n*sigma2.n/2)
}
}
contour(mu,sigma2,apost)
par(mfrow=c(1,1))
kappa.n
mu.n
kappa.0/kappa.n
n/kappa.n * mean(x)
nu.n
sigma2.n
mu
prec2
apost
View(apost)
length(prec2)
?contour
mu <- seq(1.7, 1.9, 0.0001)
prec2 <- seq(50, 170, 1)
apost <- matrix(NA, nrow = length(mu), ncol = length(prec2))
for (i in 1:length(mu)) {
for (j in 1:length(prec2)) {
apost[i, j] = dnorm(mu[i], mean = mu.n, sd = sqrt(1/(kappa.n*prec2[j]))) *
dgamma(prec2[j], nu.n/2, nu.n*sigma2.n/2)
}
}
par(mfrow = c(1,2))
contour(mu, prec2, apost)
mu <- seq(1.7, 1.9, 0.0001)
sigma2 <- seq(1/170, 1/50, 0.001)
apost <- matrix(NA, nrow = length(mu), ncol = length(sigma2))
for (i in 1:length(mu)) {
for (j in 1:length(sigma2)) {
apost[i, j] = dnorm(mu[i], mean = mu.n, sd = sqrt(sigma2[j]/kappa.n)) *
dinvgamma(sigma2[j], shape=nu.n/2, rate=nu.n*sigma2.n/2)
}
}
contour(mu,sigma2,apost)
par(mfrow=c(1,1))
mu <- seq(1.7, 1.9, 0.0001)
aposteriorna <- dt((mu-mu.n)/sqrt(sigma2.n/kappa.n), df = nu.n)/sqrt(sigma2.n/kappa.n)
plot(mu, aposteriorna, type="l", main="Robna aposteriorna porazdelitev",
xlab = expression(mu), ylab = "")
